"use strict";

let x =5;
alert(x++); // =5, т.к. сначала она возвращает 5, а потом только ++
alert(++x); // =6, в данном случае 6, т.к. сначала ++, а потом уже возвращает значение

// [] + false - null + true
// когда мы работаем с пустым массивом в таким операциям, он будет приведен к строке, а именно к пустой строке
// console.log(" "+false);
console.log([]+false); // = false
console.log([]+false-null); // = NaN 
console.log([]+false-null+true); // = NaN

let y =1;
let n = y = 2;
alert(n); // = 2


console.log([]+1+2); //= 12, т.к. пустой массив в данном случае - это строка


alert('1'[0]); // =1, т.к. [0] - обращаемся к индексу строки


//2 && 1 && null && 0 && undefined?
console.log(2 && 1 && null && 0 && undefined); // = null
// оператор && (И) всегда запинается на false, null дает false, он его и будет возвращать
// оператор ИЛИ всегда запинается на правде (true)


// есть ли разница между !!(a && b) и (a&&b)?

console.log(!!(1 && 1) === (1&&1)); // = false, они не равны
// !! превращает значение в boolean


// что выведет alert (null || 2&&3 || 4); ?
console.log(null || 2&&3 || 4); // = 3
// смотреть таблицу преоритетов операторов и смотреть по кусочкам

// a == b?
let a = [1,2,3];
let b = [1,2,3];
// нет не равно (False), т.к. это разные хранилища информации, в которых хранится разная информация


alert (+"Infinity");  // = Infinity


// Верон ли 'Ежик'>'яблоко'
console.log('Ежик'>'яблоко'); // = false
// нужно открыть таблицу юникода.
